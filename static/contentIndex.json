{"Think-Pythonically":{"slug":"Think-Pythonically","filePath":"Think Pythonically.md","title":"Think Pythonically","links":[],"tags":[],"content":"Preface\nThink Pythonically is a Python  tutorial, but unlike other tutorials, here the focus is not on the syntax, but how to think about code in Python.\nBefore starting this tutorial, it would help if you have python installed. However, you can use the python interface on this website that runs python code for you in the browser. Do delete the existing demo text before you begin!\nChapter 1: Assigning Variables\n\n\n                  \n                  Note\n                  \n                \n\n\nThis section does not produce any visible outputs. This is to learn how to think about code.\n\n\n\nYou can think of variables like boxes. You can store something in a variable, and you can store variables in other variables. It’ll make more sense once you look at the code. Variables can be named anything you like. To illustrate this point, I’ve named mine bartholomew:\nbartholomew = 5\n\nThe above line of code assigns the value of 5 to a variable named bartholomew. Now, this may sound simple enough at first, but something strange is actually going on behind the screen. Take a look at this code:\nx = 5 \ny = x \nx = 10 \n\nLooking at the above code, what do you think the value of y is once you read line 3? If you said 10, you’d be (understandably) upset to find out that the answer is 5.\nTo a programmer this may feel intuitive, obvious even, but when I first approached programming this confused me. The issue does not lie with our understanding of how variables work, but instead in understanding how the = sign works. Here is how you should be thinking of any assignment statement (think whenever = appears):\n\n\n                  \n                  Key\n                  \n                \n\n\nThis means to simplify and process as much as possible. For example, the evaluation of 2+2 would be 4.\n\n\n\nWhen you say some_variable_name = some_value, what Python does is first look at some_value as a mathematical expression to be evaluated. For example, the evaluation of 5+5 would be 10. Now how about I say “evaluate 5”? Since you’re not doing anything to the 5, you get the value 5 from evaluating it.\n\n\n                  \n                  Key\n                  \n                \n\n\nPython evaluates the expression to the right of the = and then stores the result in the variable, but does not store the expression itself. Do note, that during evaluation itself, however, python goes left to right.\nleft_hand_side = right_hand_side\nevaluates the right hand side from left to right!\n\n\n\nLooking back at the code example, let’s rewrite it a bit to show what the computer is thinking (lines with # are ignored by computer - these are called comments. Think of them like annotations for your code).\nx = 5 \n# computer evaluates 5 to result in 5 and stores this 5 in x \n\ny = x \n# computer evaluates x to result in 5 and stores this 5 in y \n\nx = 10 \n# computer evaluates 10 to result in 10 and stores this 10 in x \n\nNotice how the value of y does not change, despite it being defined as the value of x. This may seem trivial to begin with, but in a few chapters this trivial concept forms the lynchpin of various algorithmic possibilities.\nBut just using numbers isn’t particularly exciting, so let’s expand!\n# this is a string - a collection of ordered alphanumeric characters \nbartholomew = &quot;hi&quot; \n# computer evaluates &quot;hi&quot; to result in &quot;hi&quot; and stores this in the variable \n\nSurrounding any collection of alphanumeric characters in quotation marks makes them a string, such as “hi”, “hello”, “or even this text, yes you can store more than one word.”\nQuick question! Are x = 5 and y = &quot;5&quot; the same? Since I’m asking, you probably realise that the answer is no. And you’d be right, 5 is an integer, but “5” is string - a collection of one character (the character ‘5’).\n\n\n                  \n                  Key\n                  \n                \n\n\nAn algorithm is a set of steps. For example, “go straight, then take a right, and then the second left” is an algorithm to… I’m not sure where but you get the idea.\n\n\n\nChapter 2: The print statement and some tricky logic\n\n\n                  \n                  Note\n                  \n                \n\n\nThis section produces visible outputs.\n\n\n\nSo far we’ve stored a value in a variable, but if you run the code you’ll notice that nothing is outputted. This is because we haven’t told python to output anything!\nA simple function to do this is called the ‘print’ function. But before we get to that, let’s take a look at what functions are!\nHow to think about functions programmatically\nA function is a machine. You give it some raw materials, it processes them, and then produces a product. The manner in which it processes them is always the same, even if you give it varying raw materials. Like a washing machine, for example! it doesn’t matter what clothes you put in it, their colour or size, they are returned in a cleaner state (hopefully) than when you put them in. Notice that the output still depends on the input, even if the steps are the same. Most importantly, if you give the same inputs, you always get the same output.\n\nIn Python, a function is a machine, and the raw materials it takes are called arguments. For example, the print function takes a string and outputs it to the console (the giant black space to the right). The writing is identical to mathematical notation. For example,\nIn mathematical notation the function f defined as\nf(x, y) = x + y \nwould mean that\nf(5, 6) = 5 + 6 \nwhich would evaluate to\nf(5, 6) = 11\nPython has the function sum. It does the same! For example, in Python\nsum(5, 6)\n\nwould evaluate to 11.\nBut wait! Run the code above. Nothing is outputted! That’s because python performs the evaluation, but doesn’t know what to do with the result yet. Let’s tell it:\nbartholomew = sum(5, 6) \n\nThis stores the result in the variable! Remember: evaluate the right hand side first! Now that we’ve stored the value, let’s tell Python to display it.\nPython has a function to do this! That’s right, functions aren’t limited to maths. The function print takes the stuff it has to display as its input:\nprint(bartholomew)\n\nThis would evaluate bartholomew to 11 and use 11 as the input. For the print function, this would be the displaying of the string “hi” in the console. Run it and see!\n\n\n                  \n                  Note\n                  \n                \n\n\nNotice how the variable is evaluated even though there is no = sign! The inputs are always evaluated first, and the result is sent to the function process! As such,\nsum(5+5, 6) \n\nWould be the same as\nsum(10, 6) # 5+5 is evaluated \n\nWhich would evaluate to\n16 \n\n\n\n\n\n\n                  \n                  Bonus\n                  \n                \n\n\nNow try print(5)! Do you get an output? Yes? Strange? After all, didn’t I say 5 is an integer, and not a string? Well, the print function automatically converts it to a string! Pretty nifty!\n\n\n\nChapter 3: Mathematical Operators\nThe last section gave a sneak peak at this, but let’s get our heads around it anyways! First off, the basic mathematical operators remain the same:\nAddition and Subtraction\nx = 5 \ny = 10 \nz = x + y \nprint(z) \n# output should be 15 \n\nSubtraction is the simple - sign,\nx = 5 - 5 \nprint(x) # should output 0 \n\nbut division is divided into 2 forms!\nDivision\n// vs /\nEvaluating x = 11/2 results in x = 5.5\nEvaluating x = 11//2 results in x = 5\nCaught on yet? When you use //, any remainder is ignored. When you use /, it is evaluated like normal division.\nBut hey! What is 5.5? It’s not an integer, since it has a decimal value, but it’s not a string either?\nDecimal values are stored in a third form of data, called floats. You can treat them just as you would regular decimal numbers, for now.\nMultiplication and Powers\nMultiplication uses the conventional *, but putting ** means raised to the power of.\nFor example 2*5 evaluates to 10 but 2**5 evaluates to 32.\n\n\n                  \n                  Question\n                  \n                \n\n\nWhat do you think happens when a string is added to a string? For example:\nbartholomew = &quot;hi&quot; + &quot;sup&quot; \nprint(bartholomew) \n\nAnswer: The output is “hisup”! Now what about:\nbartholomew = &quot;hi&quot; + 5 \nprint(bartholomew) \n\nThe output is… an error message. Python does not allow you to add different types of data to each other (exceptions exist, such as floats and integers, like in 0.5 + 5).\n\n\n\nChapter 4: Basic Data Structures\nWhat are data structures?\nData structures are ways of/templates for organising your data. Think of a telephone directory; it’s a real-world application of a data structure! Data can be added to these in a predictable manner.\nLists are a simple example in the real world. You can make a list of many things: books you want to read, movies you want to watch, things you need to buy, things you need to do. A telephone directory is another example.\nA data structure is an arrangement of data that fulfills the following criteria:\n\nIt can contain multiple bits of data\nThe system for the arrangement of the data is known (the arrangement can be random, but this has to be known)\n\nStructures:\n\nLists\nTuples\nDictionaries\n\nLists and Tuples:\nThese are the easiest to understand.\nA list is an collection of bits of data. In Python, you can create a list like so:\nlist_variable = [&quot;hey!&quot;, &quot;this is&quot;, &quot;a list of&quot;, 5, &quot;elements!&quot; ]\n\nThe [ and ] are used to show the start and stop of lists, with each element of the list distinguished by a ,. Notice that the list can contain multiple different data types: the list above contains 4 strings, and 1 integer.\nFor tuples, simply swap the [ and ] with ( and ). What’s the difference? Well, for now let’s pretend they’re the same as lists. The difference will become clear in the next section.\nSlicing\nSay you have the list from earlier:\nlist_variable = [&quot;hey!&quot;, &quot;this is&quot;, &quot;a list of&quot;, 5, &quot;elements!&quot; ]\n\nAnd you want to find out what the 4th element of this list is. In python, you can use something called slicing.\nfourth_element = list_variable[3] \n\nPlacing a number is [ and ] next to a list results in the element at that position being returned. Here’s how python evaluates it:\nfourth_element = list_variable[3] \n→ fourth_element = [&quot;hey!&quot;, &quot;this is&quot;, &quot;a list of&quot;, 5, &quot;elements!&quot; ][3] \n→ fourth_element = 5 \n\nBut wait! Something strange: I said we were gonna get the 4th element, and we did, so why are we using 3?\nThis is a tricky concept called 0 base indexing. Sounds complicated, but it’s super easy. In python, instead of numbering elements as:\nlist_variable = [&quot;hey!&quot;, &quot;this is&quot;, &quot;a list of&quot;, 5, &quot;elements!&quot; ] \n# positions =       1       2          3         4   5 \n\nPython instead does:\nlist_variable = [&quot;hey!&quot;, &quot;this is&quot;, &quot;a list of&quot;, 5, &quot;elements!&quot; ] \n# positions =       0       1          2         3   4 \n\nThat’s right: python counts from 0, not 1. Thus, the 4th element in the list is actually at position 3.\nDictionaries\nThese are perhaps the most important basic data structure you will encounter, so focus!\nDictionaries are Python\\s built-in associative data structure. This means that they can associate one value with another. For example, let’s say we would like to associate each of the following words with their meanings, like a namesake dictionary, we would write something like this:\ntheBartholomewPythonDictionary = {&quot;print&quot; : &quot;this is a function that allows you to display text!!&quot;, &quot;len&quot; : &quot;this function finds the length of an itterable&quot;} \ntheBartholomewPythonDictionary (so named to emphasize that you can name a dictionary whatever you want) has a bunch of python function names, and a description of what they do, like a real English dictionary would have words and a description of what they mean.\nNow, suppose you would like to get the stored meaning of a given function name, you could do something like this:\nmeaning_of_print = theBartholomewEnglishDictionary[&quot;print&quot;] \nNotice that this looks like slicing, but instead of integers, we give it a key value. Python looks up this key in the dictionary, and returns the value stored.\nLike in a real dictionary, one key cannot have multiple entries. For example:\nsillyDict = { \n\t&quot;answer_to_life&quot; : 42, # PS: Using new lines makes it easier to read \n\t&quot;answer_to_life&quot; : 52, \n} ❌ \n\nwould give an error, because the same dictionary cannot have multiple entries for the same key. That said, you can duplicate values:\n \nnotSillyDict = { \n\t42 : &quot;answer_to_life&quot;, \n\t52 : &quot;answer_to_life&quot;, \n} ✅ \n \nNow, this may not look very useful right away, but here’s an example:\n\n\n                  \n                  Exercise\n                  \n                \n\n\nTry solving this problem yourself, and then check back for the answer!\n\n\n\nChapter 5: Loops\nTo be added\n \n\t \n\t\t.page-title { \n\t\t\tfont-size: 1.70rem; \n\t\t}\n\t \n"},"index":{"slug":"index","filePath":"index.md","title":"index","links":[],"tags":[],"content":" \n\twindow.location.href = `shashankraocding.github.io/thinkpythonically&#039;Think-Pythonically.html` \n\t \n \n\t \n\t\t.page-title { \n\t\t\tfont-size: 1.70rem; \n\t\t}\n\t \n"}}